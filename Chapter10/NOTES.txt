The shutil (or shell utilities) module has functions to let you copy, move, rename, and delete files in your Python programs. To use the shutil functions, you will first need to use import shutil.

Calling shutil.copy(source, destination) will copy the file at the path source to the folder at the path destination.

   >>> import shutil, os
   >>> from pathlib import Path
   >>> p = Path.home()
➊ >>> shutil.copy(p / 'spam.txt', p / 'some_folder')
   'C:\\Users\\Al\\some_folder\\spam.txt'
➋ >>> shutil.copy(p / 'eggs.txt', p / 'some_folder/eggs2.txt')
   WindowsPath('C:/Users/Al/some_folder/eggs2.txt')

While shutil.copy() will copy a single file, shutil.copytree() will copy an entire folder and every folder and file contained in it. Calling shutil.copytree(source, destination) will copy the folder at the path source, along with all of its files and subfolders, to the folder at the path destination.
>>> import shutil, os
>>> from pathlib import Path
>>> p = Path.home()
>>> shutil.copytree(p / 'spam', p / 'spam_backup')
WindowsPath('C:/Users/Al/spam_backup')

Calling shutil.move(source, destination) will move the file or folder at the path source to the path destination and will return a string of the absolute path of the new location.

If destination points to a folder, the source file gets moved into destination and keeps its current filename. For example, enter the following into the interactive shell:

>>> import shutil
>>> shutil.move('C:\\bacon.txt', 'C:\\eggs')
'C:\\eggs\\bacon.txt'

Assuming a folder named eggs already exists in the C:\ directory, this shutil.move() call says, “Move C:\bacon.txt into the folder C:\eggs.”

If there had been a bacon.txt file already in C:\eggs, it would have been overwritten. Since it’s easy to accidentally overwrite files in this way, you should take some care when using move().

The destination path can also specify a filename. In the following example, the source file is moved and renamed.

>>> shutil.move('C:\\bacon.txt', 'C:\\eggs\\new_bacon.txt')
'C:\\eggs\\new_bacon.txt'

You can delete a single file or a single empty folder with functions in the os module, whereas to delete a folder and all of its contents, you use the shutil module.

Calling os.unlink(path) will delete the file at path.
Calling os.rmdir(path) will delete the folder at path. This folder must be empty of any files or folders.
Calling shutil.rmtree(path) will remove the folder at path, and all files and folders it contains will also be deleted.

import os
from pathlib import Path
for filename in Path.home().glob('*.rxt'):
    os.unlink(filename)
this will delete all rxt files

Since Python’s built-in shutil.rmtree() function irreversibly deletes files and folders, it can be dangerous to use. A much better way to delete files and folders is with the third-party send2trash module.
Using send2trash is much safer than Python’s regular delete functions, because it will send folders and files to your computer’s trash or recycle bin instead of permanently deleting them.
>>> import send2trash
>>> baconFile = open('bacon.txt', 'a')   # creates the file
>>> baconFile.write('Bacon is not a vegetable.')
25
>>> baconFile.close()
>>> send2trash.send2trash('bacon.txt')
Note that the send2trash() function can only send files to the recycle bin; it cannot pull files out of it.

The os.walk() function is passed a single string value: the path of a folder. You can use os.walk() in a for loop statement to walk a directory tree, much like how you can use the range() function to walk over a range of numbers. Unlike range(), the os.walk() function will return three values on each iteration through the loop:

A string of the current folder’s name
A list of strings of the folders in the current folder
A list of strings of the files in the current folder

import os

for folderName, subfolders, filenames in os.walk('C:\\delicious'):
    print('The current folder is ' + folderName)

    for subfolder in subfolders:
        print('SUBFOLDER OF ' + folderName + ': ' + subfolder)

    for filename in filenames:
        print('FILE INSIDE ' + folderName + ': '+ filename)

    print('')


Your Python programs can create and open (or extract) ZIP files using functions in the zipfile module.

To read the contents of a ZIP file, first you must create a ZipFile object (note the capital letters Z and F). ZipFile objects are conceptually similar to the File objects you saw returned by the open() function in the previous chapter: they are values through which the program interacts with the file. To create a ZipFile object, call the zipfile.ZipFile() function, passing it a string of the .ZIP file’s filename. Note that zipfile is the name of the Python module, and ZipFile() is the name of the function.
  >>> import zipfile, os

   >>> from pathlib import Path
   >>> p = Path.home()
   >>> exampleZip = zipfile.ZipFile(p / 'example.zip')
   >>> exampleZip.namelist()
   ['spam.txt', 'cats/', 'cats/catnames.txt', 'cats/zophie.jpg']
   >>> spamInfo = exampleZip.getinfo('spam.txt')
   >>> spamInfo.file_size
   13908
   >>> spamInfo.compress_size
   3828
➊ >>> f'Compressed file is {round(spamInfo.file_size / spamInfo
   .compress_size, 2)}x smaller!'
   )
   'Compressed file is 3.63x smaller!'
   >>> exampleZip.close()

The extractall() method for ZipFile objects extracts all the files and folders from a ZIP file into the current working directory.
  >>> import zipfile, os
   >>> from pathlib import Path
   >>> p = Path.home()
   >>> exampleZip = zipfile.ZipFile(p / 'example.zip')
➊ >>> exampleZip.extractall()
   >>> exampleZip.close()